---
title: ADR-0001 RBAC/RLS 方式の選定
description: ロールベースアクセス制御とRow Level Securityの実装方式を決定する
---

## ステータス
- **Accepted**（2026-02-22）

## コンテキスト
OpsHub は複数のロール（Member, Approver, PM, Accounting, IT Admin, Tenant Admin）を持つマルチテナント業務アプリである。
各ロールに応じた画面アクセス・データアクセスの制御が必要。以下を決定する必要がある：
1. ロール情報をどこに持つか
2. 認可チェックをどの層で行うか
3. RLSとアプリ層の役割分担

## 選択肢

### 案A: user_roles テーブル + RLS ポリシー（採用）
- `user_roles` テーブルでユーザー×テナント×ロールを管理
- PostgreSQL RLS でデータアクセスを制御
- 画面レベルのアクセス制御は Middleware + Server Component で実施

### 案B: Supabase Custom Claims（JWT埋め込み）
- JWTにロール情報を埋め込む
- RLSで `auth.jwt()->'role'` を参照
- ロール変更時にJWTリフレッシュが必要（即時反映されない）

### 案C: アプリ層のみで制御（RLS不使用）
- 全アクセスを server actions / API で制御
- RLSなし＝DBレベルのセキュリティなし

## 決定
- **採用**: 案A（user_roles テーブル + RLS ポリシー）
- **採用理由**:
  - RLSによるDB層での強制的なアクセス制御（防御の深さ）
  - ロール変更が即時反映される（JWTリフレッシュ不要）
  - テナント分離も同じRLSレイヤーで統合可能（ADR-0003参照）
  - Supabase公式ドキュメントでも推奨されるパターン

## 影響
- **正の影響**:
  - DB層でのセキュリティ保証（アプリのバグがあってもデータ漏洩を防止）
  - ロール変更の即時反映
  - PostgRESTクエリもRLSで自動保護
- **負の影響**:
  - RLSポリシーの複雑化リスク（ロール×テナント×リソース）
  - RLSポリシーのテストが必要
  - パフォーマンス: JOINを伴うRLSポリシーは慎重に設計する必要あり
- **移行/ロールバック**:
  - 案Bへの移行は可能だが、全RLSポリシーの書き換えが必要

## 実装方針（概要）
```sql
-- user_roles テーブル
CREATE TABLE user_roles (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) NOT NULL,
  tenant_id uuid REFERENCES tenants(id) NOT NULL,
  role text NOT NULL CHECK (role IN ('member','approver','pm','accounting','it_admin','tenant_admin')),
  created_at timestamptz DEFAULT now(),
  UNIQUE(user_id, tenant_id, role)
);

-- RLSポリシーでの使用例
CREATE POLICY "tenant_member_select" ON projects
  FOR SELECT USING (
    tenant_id IN (
      SELECT tenant_id FROM user_roles
      WHERE user_id = auth.uid()
    )
  );
```

## Related
- REQ-A01（テナント/権限管理） / ADR-0003（マルチテナント） / DD-DB-001（user_roles）
